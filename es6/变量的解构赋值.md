# 变量的解构赋值

```javascript
从数组和对象中提取值，对变量进行赋值，叫做解构赋值。
“模式匹配”
// 举例
let [a,b,c] = [1,2,3];
```

## 解构举例

```javascript
//第一种情况：形式复杂均可解
let [foo1,[[foo2],foo3]] = [1,[[2],3]] 
console.log(foo1) // 1
console.log(foo2) // 2
console.log(foo3) // 3

// 第二种情况：留空
let [,,foo4] = ["kong","kong",4] //  挖坑
console.log(foo4) // 4 
let [foo5,,foo6] = [5,"kong",6]
console.log(foo5) // 5 
console.log(foo6) // 6 

// 第三种情况：三个点即剩余凑数组
let [foo7,...foo8] = [7,7,7,7,8]
console.log(foo7) // 7 
console.log(foo8) // [7,7,7,8]  

// 第四种情况：虽未分配值，但在左边已经进行了声明
let [foo9,foo10,...foo11] = [10];
console.log(foo9) // 10 默认匹配第一个 
console.log(foo10) // undefined
console.log(foo11) // [] 注意这里没有成为undfined，而是为空数组

// 第五种情况：右为空则为undefined
let [foo12] = []
let [foo13,foo14] = [13]
console.log(foo12) // undefined
console.log(foo13) // 13 
console.log(foo14) // undefined

// 第六种情况：左可瘦右需肥
let [foo15,foo16] = [15,16,16]
console.log(foo15) // 15 
console.log(foo16) // 16 
let [foo17,[foo18],foo19] = [17,[18,18],19]
console.log(foo17) // 17 
console.log(foo18) // 18 注意这里是18，而不是数组。与...自动生成的数组要区别
console.log(foo19) // 19 

// 第七种情况：不完全
```

## 解构条件

- 数组
- 对象
- 具有```Iterator```及接口即可，比如Set解构

## 默认值

```javascript
let [foo = true] = [];

let [x,y = 'b'] = ['a'];
let [x,y = 'b'] = ['a',undefined];

let [x = 1] = [null];
```

### 默认值 = 函数？

```javascript
如果是等于一个函数，则默认为惰性求值的，只有在用到的时候才会求值！
function foo() {
   console.log("aaa")
}
let [a = foo()] = []
console.log(a)  // 会输出 aaa undefined

但如果是
let [a = foo()] = [1]
则会输出 1
```

